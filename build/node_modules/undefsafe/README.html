<h1>undefsafe</h1><p>Simple <em>function</em> for retrieving deep object properties without getting &quot;Cannot read property &#39;X&#39; of undefined&quot;</p>
<p>Can also be used to safely set deep values.</p>
<h2>Usage</h2><pre><code class="language-js">var object = {
  a: {
    b: {
      c: 1,
      d: [1,2,3],
      e: &#39;remy&#39;
    }
  }
};

console.log(undefsafe(object, &#39;a.b.e&#39;)); // &quot;remy&quot;
console.log(undefsafe(object, &#39;a.b.not.found&#39;)); // undefined
</code></pre>
<p>Demo: <a href="https://jsbin.com/eroqame/3/edit?js,console">https://jsbin.com/eroqame/3/edit?js,console</a></p>
<h2>Setting</h2><pre><code class="language-js">var object = {
  a: {
    b: [1,2,3]
  }
};

// modified object
var res = undefsafe(object, &#39;a.b.0&#39;, 10);

console.log(object); // { a: { b: [10, 2, 3] } }
console.log(res); // 1 - previous value
</code></pre>
<h2>Star rules in paths</h2><p>As of 1.2.0, <code>undefsafe</code> supports a <code>*</code> in the path if you want to search all of the properties (or array elements) for a particular element.</p>
<p>The function will only return a single result, either the 3rd argument validation value, or the first positive match. For example, the following github data:</p>
<pre><code class="language-js">const githubData = {
        commits: [{
          modified: [
            &quot;one&quot;,
            &quot;two&quot;
          ]
        }, /* ... */ ]
      };

// first modified file found in the first commit
console.log(undefsafe(githubData, &#39;commits.*.modified.0&#39;));

// returns `two` or undefined if not found
console.log(undefsafe(githubData, &#39;commits.*.modified.*&#39;, &#39;two&#39;));
</code></pre>
